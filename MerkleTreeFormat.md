# MerkleTree Binary Format
## MerkleTree Format

The merkle tree is serialized in ProtoBuffer format. The proto files list as below:

    message MerkleTree {
        repeated string tokens = 1; // token and its index
        repeated MerkleNode nodes = 2;
    }

The tree binary file start with a list of token names, like BTC, ETH, etc. And the index for the token is used to represent the token itself in the corresponding representation [1].

the second filed is a list of MerkleNode message, it represents a single node in binary merkle tree. The format is shown as below:

    message MerkleNode {
        optional bytes hash = 1;  
        optional bytes left= 2; // hash of left merkle node  
        optional bytes right = 3;  
        optional bytes parent = 4;  
        MerkleBalanceVector balance = 5;
    }

MerkleNode have attribute hash, as described by the merkle tree spec (https://blog.bitmex.com/addressing-the-privacy-gap-in-proof-of-liability-protocols/ ) . Each MerkleNode has attribute left, it’s the hash of the left child of current node. When the tree is loaded, we can construct the binary tree structure using the left, right and parent field.

Remember the hash of intermediary MerkleNode(non-leaf) is generated by:

    sha256(concat(left_child.hash, right_child.hash))

And the hash of leaf MerkleNode is generated by:

    sha256(user_hash, leaf_balance_vector, leaf_position_index)

for the leaf_balance_vector and leaf_position_index part, we use the MerkleBalanceVector proto message as the byte array input. the format is shown as below:

    message MerkleBalanceVector {
        repeated int32 index = 1;   
        repeated string balances = 2;  
        optional int32 leafIndex = 3;
    }

the index field is a list of tokens, we can find the mapping for the token-string-representation in [1]. The balances is the string format quantity of each token, like “13.3434442222”, and you have to convert it to number for further calculation.

So the calculation process of leaf node hash is as follow:

    MerkleBalanceVector merkleBalanceVector = build(); // construct the MerkleBalanceVector message.
    byte[] bytes = merkleBalanceVector.serialized().toByteArray(); // get the serialized bytes of the message.
    byte[] userHash = doGetUserHash() // get user hash by whatever means.
    byte[] hashOfLeaf = sha256(concat(userHash, bytes)); // get the hash of leaf node.

And finally, the userHash use ProtoBuffuer message like this:

    message UserHash {
        int64 uid = 1;    
        string nonce = 2;    
        int64 timestamp = 3;
    }

    UserHash userHash = build(); // build user hash message.
    byte[] bytes = userHash.serialized().toByteArray();
    byte[] userHash = sha256(bytes); // get the user hash byte array.

## TreeStructure

The leaf nodes are users' balance split by N parts (say 10),  and the MerkleTree is a binary tree. In order for the leaf node in the same level, some leaf parents will only have single left child.

And we want to make sure every Level 2 node has at least one child. So we will assign at least one leaf node to every Level2 node, and assign the remaining leaf node from left to right.

![the merkle tree structure](tree.jpeg)