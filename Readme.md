# The merkle tree validate sample code

The sample code demonstrate how to validate the merkle tree. The sample code is written in Java,
it consists of only 1 java file `MerkleCheck.java`. 

The entry point is the `main()` function in `MerkleCheck.java`, there are only two variable you need to provide and substitute:
1. Path of the Merkle tree binary file. (download from WOO X website)
2. User hash of your account for the specified audit. (obtain from WOO X after logging in)

With the two inputs provided, the sample code tries to run the merkle tree validation process, and retrieves
the balance of your account for the audit. You are welcome to review the code yourself to verify the validation approach.

# Merkle Tree Binary Format
## Tree Structure

The leaf nodes are users' balance split by N parts (determined at random for each audit), and the Merkle Tree is a binary tree. Each leaf node therefore represents a portion of each user's balance at the time of the Audit snapshot, and the root node represents all users' balance at the time of the Audit snapshot. 

Any accounts with no assets or did not pass KYC will not be represented on the Merkle tree. Also, any negative assets are not reflected on the tree to ensure no misrepresented negative balances can be added to the tree to under-report the overall sum of the users' balances. Each subaccount is represented separately from the main account in the tree.

In order for the leaf nodes to be in the same level, some leaf parents will only have single left child. We also ensure every Level 2 node has at least one child. So we will assign at least one leaf node to every Level 2 node, and assign the remaining leaf node from left to right.

![the merkle tree structure](tree.jpeg)

## Merkle Tree Format

The merkle tree is serialized in ProtoBuffer format. The proto files are as follows:

    message MerkleTree {
        repeated string tokens = 1; // token and its index
        repeated MerkleNode nodes = 2;
    }

The tree binary file start with a list of token names (eg BTC, ETH), and the index for the token is used to represent the token itself in the corresponding representation [1].

The second file is a list of MerkleNode messages, it represents a single node in the merkle tree. The format is as below:

    message MerkleNode {
        optional bytes hash = 1;  
        optional bytes left= 2; // hash of left merkle node  
        optional bytes right = 3;  // hash of right merkle node
        optional bytes parent = 4;  
        MerkleBalanceVector balance = 5;
    }

The attribute `left`/`right` are the hashes of the left/right child of current node. When the tree is loaded, we can construct the binary tree structure using the left, right and parent attributes.

The `hash` attribute represents the hash of the Node. The hash of intermediary MerkleNode (non-leaf) is generated by:

```
    sha256(concat(left_child.hash, right_child.hash))
```

And the hash of leaf MerkleNode is generated by:

```
    sha256(user_hash, leaf_balance_vector, leaf_position_index)
```

For the `leaf_balance_vector` and `leaf_position_index` parts, we use the `MerkleBalanceVector` proto message as the byte array input. the format is shown as below:

    message MerkleBalanceVector {
        repeated int32 index = 1;   
        repeated string balances = 2;  
        optional int32 leafIndex = 3;
    }

The `index` attribute is a list of tokens, we can find the mapping for the token-string-representation in [1]. The `balances` attribute represents the quantity of each token.

The calculation process of leaf node hash is as follows:

    MerkleBalanceVector merkleBalanceVector = build(); // construct the MerkleBalanceVector message.
    byte[] bytes = merkleBalanceVector.serialized().toByteArray(); // serialized bytes of the message.
    byte[] userHash = doGetUserHash() // user hash.
    byte[] hashOfLeaf = sha256(concat(userHash, bytes)); // hash of leaf node.

And finally, the userHash use ProtoBuffuer message like this:

    message UserHash {
        int64 uid = 1;    
        string nonce = 2;    
        int64 timestamp = 3;
    }

    UserHash userHash = build(); // build user hash message.
    byte[] bytes = userHash.serialized().toByteArray();
    byte[] userHash = sha256(bytes); // get the user hash byte array.

# Validation Algorithm

The validation algorithm attempts to find all leaf nodes that matches the `UserHash` by calculating the `hash` of the leaf nodes based on the `UserHash` input and comparing against the `hash` of the leaf node. Matches are ensured to be unique by adding the `leafIndex` which is the leaf's unique id in the tree. 

After finding all matched leaf nodes, the algorithm will sum up the balances of the leaf nodes, which should then equal the total balances of the account at the time of the snapshot (also provided in the WOO X Audit page after logging in for each account/subaccount).
